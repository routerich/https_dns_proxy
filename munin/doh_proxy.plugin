#!/bin/bash

case $1 in
  config)
    cat <<'EOM'
multigraph doh_proxy_count
graph_title DoH proxy - count
graph_vlabel count
graph_category network
graph_scale no
graph_args --base 1000 --lower-limit 0
requests.label Requests
responses.label Responses

multigraph doh_proxy_latency
graph_title DoH proxy - latency
graph_vlabel latency
graph_category network
graph_scale no
graph_args --base 1000 --lower-limit 0
latency.label Latency

multigraph doh_proxy_connections
graph_title DoH proxy - connections
graph_vlabel count
graph_category network
graph_scale no
graph_args --base 1000 --lower-limit 0
opened.label Opened
closed.label Closed
reused.label Reused
EOM
    exit 0;;

  autoconf)
    pgrep doh_proxy >/dev/null 2>&1 \
      && echo "yes" \
      || echo "no"
    exit 0;;
esac

log_lines=$(journalctl --unit doh_proxy.service --output cat --since '6 minutes ago')
pattern='stat\.c:[0-9]+ ([0-9]+) ([0-9]+) ([0-9]+) ([0-9]+) ([0-9]+) ([0-9]+) ([0-9]+) ([0-9]+)$'

# match log lines with pattern (last match will be used)
IFS='
'
for line in $log_lines; do
  if [[ $line =~ $pattern ]]; then
    stat=("${BASH_REMATCH[@]}")
  # else
  #   echo "stat regexp did not match with line: $line" >&2
  fi
done

latency='U'
if [ -n "${stat[3]}" ] && \
   [ -n "${stat[2]}" ] && \
   [ "${stat[2]}" -gt "0" ]; then
  latency=$((${stat[3]} / ${stat[2]}))
fi

echo "multigraph doh_proxy_count"
echo "requests.value ${stat[1]:-U}"
echo "responses.value ${stat[2]:-U}"
echo "multigraph doh_proxy_latency"
echo "latency.value ${latency}"
echo "multigraph doh_proxy_connections"
echo "opened.value ${stat[6]:-U}"
echo "closed.value ${stat[7]:-U}"
echo "reused.value ${stat[8]:-U}"
